package b.c.a.a;

import android.content.Context;
import c.a.a.a.g.f;
import c.a.a.a.n.p;
import c.a.a.a.w;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PushbackInputStream;
import java.lang.reflect.Field;
import java.net.URI;
import java.net.URL;
import java.net.URLDecoder;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.zip.GZIPInputStream;

public class d
{
  public static k a = new j();
  private final c.a.a.a.i.b.k b;
  private final c.a.a.a.n.e c;
  private final Map<Context, List<q>> d;
  private final Map<String, String> e;
  private int f = 10;
  private int g = 10000;
  private int h = 10000;
  private ExecutorService i;
  private boolean j;
  
  public d()
  {
    this(false, 80, 443);
  }
  
  public d(c.a.a.a.e.c.i paramI)
  {
    boolean bool = true;
    j = true;
    c.a.a.a.l.b localB = new c.a.a.a.l.b();
    c.a.a.a.e.a.c.a(localB, g);
    c.a.a.a.e.a.c.a(localB, new c.a.a.a.e.a.e(f));
    c.a.a.a.e.a.c.a(localB, 10);
    c.a.a.a.l.e.b(localB, h);
    c.a.a.a.l.e.a(localB, g);
    c.a.a.a.l.e.a(localB, true);
    c.a.a.a.l.e.c(localB, 8192);
    c.a.a.a.l.i.a(localB, w.f);
    paramI = a(paramI, localB);
    if (paramI == null) {
      bool = false;
    }
    u.a(bool, "Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null");
    i = a();
    d = Collections.synchronizedMap(new WeakHashMap());
    e = new HashMap();
    c = new p(new c.a.a.a.n.a());
    b = new c.a.a.a.i.b.k(paramI, localB);
    b.a(new a(this));
    b.a(new b(this));
    b.a(new c(this), 0);
    b.a(new t(5, 1500));
  }
  
  public d(boolean paramBoolean, int paramInt1, int paramInt2)
  {
    this(a(paramBoolean, paramInt1, paramInt2));
  }
  
  private static c.a.a.a.e.c.i a(boolean paramBoolean, int paramInt1, int paramInt2)
  {
    if (paramBoolean) {
      a.d("AsyncHttpClient", "Beware! Using the fix is insecure, as it doesn't verify SSL certificates.");
    }
    int k = paramInt1;
    if (paramInt1 < 1)
    {
      k = 80;
      a.d("AsyncHttpClient", "Invalid HTTP port number specified, defaulting to 80");
    }
    paramInt1 = paramInt2;
    if (paramInt2 < 1)
    {
      paramInt1 = 443;
      a.d("AsyncHttpClient", "Invalid HTTPS port number specified, defaulting to 443");
    }
    c.a.a.a.e.e.i localI;
    if (paramBoolean) {
      localI = n.b();
    } else {
      localI = c.a.a.a.e.e.i.a();
    }
    c.a.a.a.e.c.i localI1 = new c.a.a.a.e.c.i();
    localI1.a(new c.a.a.a.e.c.e("http", c.a.a.a.e.c.d.a(), k));
    localI1.a(new c.a.a.a.e.c.e("https", localI, paramInt1));
    return localI1;
  }
  
  public static String a(boolean paramBoolean, String paramString, r paramR)
  {
    if (paramString == null) {
      return null;
    }
    Object localObject = paramString;
    String str;
    if (paramBoolean) {
      try
      {
        localObject = new URL(URLDecoder.decode(paramString, "UTF-8"));
        localObject = new URI(((URL)localObject).getProtocol(), ((URL)localObject).getUserInfo(), ((URL)localObject).getHost(), ((URL)localObject).getPort(), ((URL)localObject).getPath(), ((URL)localObject).getQuery(), ((URL)localObject).getRef()).toASCIIString();
      }
      catch (Exception localException)
      {
        a.b("AsyncHttpClient", "getUrlWithQueryString encoding URL", localException);
        str = paramString;
      }
    }
    if (paramR == null) {
      return str;
    }
    paramR.a();
    throw null;
  }
  
  public static void a(c.a.a.a.l paramL)
  {
    Object localObject2;
    if ((paramL instanceof f)) {
      localObject2 = null;
    }
    for (;;)
    {
      int k;
      try
      {
        Field[] arrayOfField = f.class.getDeclaredFields();
        int m = arrayOfField.length;
        k = 0;
        Object localObject1 = localObject2;
        if (k < m)
        {
          localObject1 = arrayOfField[k];
          if (!((Field)localObject1).getName().equals("wrappedEntity")) {
            break label98;
          }
        }
        if (localObject1 != null)
        {
          ((Field)localObject1).setAccessible(true);
          paramL = (c.a.a.a.l)((Field)localObject1).get(paramL);
          if (paramL != null)
          {
            paramL.consumeContent();
            return;
          }
        }
      }
      catch (Throwable paramL)
      {
        a.b("AsyncHttpClient", "wrappedEntity consume", paramL);
      }
      return;
      label98:
      k += 1;
    }
  }
  
  public static void a(InputStream paramInputStream)
  {
    if (paramInputStream != null) {
      try
      {
        paramInputStream.close();
        return;
      }
      catch (IOException paramInputStream)
      {
        a.a("AsyncHttpClient", "Cannot close input stream", paramInputStream);
      }
    }
  }
  
  public static void a(OutputStream paramOutputStream)
  {
    if (paramOutputStream != null) {
      try
      {
        paramOutputStream.close();
        return;
      }
      catch (IOException paramOutputStream)
      {
        a.a("AsyncHttpClient", "Cannot close output stream", paramOutputStream);
      }
    }
  }
  
  public static void a(Class<?> paramClass)
  {
    if (paramClass != null) {
      t.a(paramClass);
    }
  }
  
  public static boolean a(PushbackInputStream paramPushbackInputStream)
  {
    boolean bool = false;
    if (paramPushbackInputStream == null) {
      return false;
    }
    byte[] arrayOfByte = new byte[2];
    int k = 0;
    for (;;)
    {
      if (k < 2) {}
      try
      {
        int m = paramPushbackInputStream.read(arrayOfByte, k, 2 - k);
        if (m < 0) {
          return false;
        }
        k += m;
      }
      finally
      {
        paramPushbackInputStream.unread(arrayOfByte, 0, k);
      }
    }
    if (35615 == (arrayOfByte[0] & 0xFF | arrayOfByte[1] << 8 & 0xFF00)) {
      bool = true;
    }
    return bool;
  }
  
  protected e a(c.a.a.a.i.b.k paramK, c.a.a.a.n.e paramE, c.a.a.a.b.c.l paramL, String paramString, s paramS, Context paramContext)
  {
    return new e(paramK, paramE, paramL, paramS);
  }
  
  public q a(Context paramContext, String paramString, r paramR, s paramS)
  {
    return b(b, c, new i(a(j, paramString, paramR)), null, paramS, paramContext);
  }
  
  public q a(Context paramContext, String paramString, s paramS)
  {
    return a(paramContext, paramString, null, paramS);
  }
  
  public q a(Context paramContext, String paramString, c.a.a.a.e[] paramArrayOfE, r paramR, s paramS)
  {
    paramString = new i(a(j, paramString, paramR));
    if (paramArrayOfE != null) {
      paramString.a(paramArrayOfE);
    }
    return b(b, c, paramString, null, paramS, paramContext);
  }
  
  protected c.a.a.a.e.b a(c.a.a.a.e.c.i paramI, c.a.a.a.l.b paramB)
  {
    return new c.a.a.a.i.c.a.i(paramB, paramI);
  }
  
  protected ExecutorService a()
  {
    return Executors.newCachedThreadPool();
  }
  
  public void a(int paramInt)
  {
    int k = paramInt;
    if (paramInt < 1000) {
      k = 10000;
    }
    g = k;
    c.a.a.a.l.g localG = b.B();
    c.a.a.a.e.a.c.a(localG, g);
    c.a.a.a.l.e.a(localG, g);
  }
  
  public void a(boolean paramBoolean)
  {
    a(paramBoolean, paramBoolean, paramBoolean);
  }
  
  public void a(boolean paramBoolean1, boolean paramBoolean2, boolean paramBoolean3)
  {
    b.B().setBooleanParameter("http.protocol.reject-relative-redirect", paramBoolean2 ^ true);
    b.B().setBooleanParameter("http.protocol.allow-circular-redirects", paramBoolean3);
    b.a(new l(paramBoolean1));
  }
  
  public q b(Context paramContext, String paramString, c.a.a.a.e[] paramArrayOfE, r paramR, s paramS)
  {
    paramString = new c.a.a.a.b.c.j(a(j, paramString, paramR));
    if (paramArrayOfE != null) {
      paramString.a(paramArrayOfE);
    }
    return b(b, c, paramString, null, paramS, paramContext);
  }
  
  protected q b(c.a.a.a.i.b.k paramK, c.a.a.a.n.e paramE, c.a.a.a.b.c.l paramL, String arg4, s paramS, Context paramContext)
  {
    if (paramL != null)
    {
      if (paramS != null)
      {
        if ((paramS.b()) && (!paramS.a())) {
          throw new IllegalArgumentException("Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.");
        }
        if (??? != null) {
          if (((paramL instanceof c.a.a.a.b.c.g)) && (((c.a.a.a.b.c.g)paramL).getEntity() != null) && (paramL.containsHeader("Content-Type"))) {
            a.a("AsyncHttpClient", "Passed contentType will be ignored because HttpEntity sets content type");
          } else {
            paramL.setHeader("Content-Type", ???);
          }
        }
        paramS.a(paramL.getAllHeaders());
        paramS.a(paramL.getURI());
        paramK = a(paramK, paramE, paramL, ???, paramS, paramContext);
        i.submit(paramK);
        paramL = new q(paramK);
        if (paramContext != null) {
          synchronized (d)
          {
            paramE = (List)d.get(paramContext);
            paramK = paramE;
            if (paramE == null)
            {
              paramK = Collections.synchronizedList(new LinkedList());
              d.put(paramContext, paramK);
            }
            paramK.add(paramL);
            paramK = paramK.iterator();
            while (paramK.hasNext()) {
              if (((q)paramK.next()).c()) {
                paramK.remove();
              }
            }
          }
        }
        return paramL;
      }
      throw new IllegalArgumentException("ResponseHandler must not be null");
    }
    paramK = new IllegalArgumentException("HttpUriRequest must not be null");
    for (;;)
    {
      throw paramK;
    }
  }
  
  public void b(int paramInt)
  {
    int k = paramInt;
    if (paramInt < 1000) {
      k = 10000;
    }
    h = k;
    c.a.a.a.l.e.b(b.B(), h);
  }
  
  public void c(int paramInt)
  {
    int k = paramInt;
    if (paramInt < 1000) {
      k = 10000;
    }
    a(k);
    b(k);
  }
  
  private static class a
    extends f
  {
    InputStream b;
    PushbackInputStream c;
    GZIPInputStream d;
    
    public a(c.a.a.a.l paramL)
    {
      super();
    }
    
    public void consumeContent()
    {
      d.a(b);
      d.a(c);
      d.a(d);
      super.consumeContent();
    }
    
    public InputStream getContent()
    {
      b = a.getContent();
      c = new PushbackInputStream(b, 2);
      if (d.a(c))
      {
        d = new GZIPInputStream(c);
        return d;
      }
      return c;
    }
    
    public long getContentLength()
    {
      c.a.a.a.l localL = a;
      if (localL == null) {
        return 0L;
      }
      return localL.getContentLength();
    }
  }
}
