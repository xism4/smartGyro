package c.a.a.a.b.c;

import c.a.a.a.e.e;
import c.a.a.a.e.i;
import c.a.a.a.l.g;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public abstract class d
  extends c.a.a.a.k.a
  implements h, a, Cloneable, c.a.a.a.r
{
  private final AtomicBoolean c = new AtomicBoolean(false);
  private final AtomicReference<c.a.a.a.c.a> d = new AtomicReference(null);
  
  protected d() {}
  
  public void a(c.a.a.a.c.a paramA)
  {
    if (!c.get()) {
      d.set(paramA);
    }
  }
  
  @Deprecated
  public void a(e paramE)
  {
    a(new b(this, paramE));
  }
  
  @Deprecated
  public void a(i paramI)
  {
    a(new c(this, paramI));
  }
  
  public void abort()
  {
    if (c.compareAndSet(false, true))
    {
      c.a.a.a.c.a localA = (c.a.a.a.c.a)d.getAndSet(null);
      if (localA != null) {
        localA.cancel();
      }
    }
  }
  
  public Object clone()
  {
    d localD = (d)super.clone();
    a = ((c.a.a.a.k.r)c.a.a.a.b.f.a.a(a));
    b = ((g)c.a.a.a.b.f.a.a(b));
    return localD;
  }
  
  public boolean isAborted()
  {
    return c.get();
  }
}
